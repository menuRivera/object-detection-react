{"version":3,"sources":["useModel.js","object-detection-video/useWebcam.js","object-detection-video/retina-canvas.js","object-detection-video/render-predictions.js","object-detection-video/ObjectDetectionVideo.js","index.js"],"names":["useModel","modelPath","_useState","useState","_useState2","Object","slicedToArray","model","setModel","useEffect","models","load","then","useWebcam","videoRef","onLoaded","navigator","mediaDevices","getUserMedia","audio","video","facingMode","width","ideal","height","stream","current","srcObject","onloadedmetadata","getRetinaContext","canvas","ctx","getContext","scale","window","devicePixelRatio","setWidth","w","style","setHeight","h","clearAll","clearRect","x","y","setFont","font","size","parseInt","retinaFont","replace","setTextBaseLine","textBaseline","setStrokeStyle","strokeStyle","setLineWidth","lineWidth","strokeRect","setFillStyle","fillStyle","measureText","text","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillRect","fillText","getLabelText","prediction","scoreText","score","toFixed","concat","label","renderPredictions","predictions","textHeight","forEach","bbox","predictionText","Math","round","textWidth","border","xPadding","yPadding","ObjectDetectionVideo","React","memo","_ref","onPrediction","fit","mirrored","render","useRef","canvasRef","detectFrame","useCallback","asyncToGenerator","regenerator_default","a","mark","_callee","wantedWidth","wantedHeight","videoWidth","videoHeight","scaleX","scaleY","xOffset","yOffset","offsetPredictions","wrap","_context","prev","next","detect","sent","offsetWidth","offsetHeight","min","max","map","_objectSpread","requestAnimationFrame","stop","position","left","top","objectFit","transform","react_default","createElement","autoPlay","playsInline","muted","ref","rootElement","document","getElementById","ReactDOM","className","object_detection_video_ObjectDetectionVideo"],"mappings":"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","file":"static/js/main.57fc3379.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\n\nimport models from '@cloud-annotations/models'\n\nconst useModel = (modelPath) => {\n  const [model, setModel] = useState()\n  useEffect(() => {\n    models.load(modelPath).then((model) => {\n      setModel(model)\n    })\n  }, [modelPath])\n  return model\n}\n\nexport default useModel\n","import { useEffect } from 'react'\n\nconst useWebcam = (videoRef, onLoaded) => {\n  useEffect(() => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user',\n            width: { ideal: 4096 },\n            height: { ideal: 2160 },\n          },\n        })\n        .then((stream) => {\n          videoRef.current.srcObject = stream\n          videoRef.current.onloadedmetadata = () => {\n            onLoaded()\n          }\n        })\n    }\n  }, [onLoaded, videoRef])\n}\n\nexport default useWebcam\n","export const getRetinaContext = (canvas) => {\n  const ctx = canvas.getContext('2d')\n  const scale = window.devicePixelRatio\n  let width = canvas.width / scale\n  let height = canvas.height / scale\n  return {\n    setWidth: (w) => {\n      width = w\n      canvas.style.width = w + 'px'\n      canvas.width = w * scale\n    },\n    setHeight: (h) => {\n      height = h\n      canvas.style.height = h + 'px'\n      canvas.height = h * scale\n    },\n    width: width,\n    height: height,\n    clearAll: () => {\n      return ctx.clearRect(0, 0, width * scale, height * scale)\n    },\n    clearRect: (x, y, width, height) => {\n      return ctx.clearRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    setFont: (font) => {\n      const size = parseInt(font, 10) * scale\n      const retinaFont = font.replace(/^\\d+px/, size + 'px')\n      ctx.font = retinaFont\n    },\n    setTextBaseLine: (textBaseline) => {\n      ctx.textBaseline = textBaseline\n    },\n    setStrokeStyle: (strokeStyle) => {\n      ctx.strokeStyle = strokeStyle\n    },\n    setLineWidth: (lineWidth) => {\n      ctx.lineWidth = lineWidth * scale\n    },\n    strokeRect: (x, y, width, height) => {\n      return ctx.strokeRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    setFillStyle: (fillStyle) => {\n      ctx.fillStyle = fillStyle\n    },\n    measureText: (text) => {\n      const metrics = ctx.measureText(text)\n      return {\n        width: metrics.width / scale,\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft / scale,\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight / scale,\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent / scale,\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent / scale,\n      }\n    },\n    fillRect: (x, y, width, height) => {\n      return ctx.fillRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    fillText: (text, x, y) => {\n      return ctx.fillText(text, x * scale, y * scale)\n    },\n  }\n}\n","const getLabelText = (prediction) => {\n  const scoreText = (prediction.score * 100).toFixed(1)\n  return `${prediction.label} ${scoreText}%`\n}\n\nexport const renderPredictions = (ctx, predictions) => {\n  // Font options.\n  const font = `${16}px 'ibm-plex-sans', Helvetica Neue, Arial, sans-serif`\n  ctx.setFont(font)\n  ctx.setTextBaseLine('top')\n  const border = 4\n  const xPadding = 16\n  const yPadding = 8\n  const offset = 6\n  const textHeight = parseInt(font, 10) // base 10\n\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    const width = prediction.bbox[2]\n    const height = prediction.bbox[3]\n\n    const predictionText = getLabelText(prediction)\n\n    // Draw the bounding box.\n    ctx.setStrokeStyle('#0062ff')\n    ctx.setLineWidth(border)\n\n    ctx.strokeRect(\n      Math.round(x),\n      Math.round(y),\n      Math.round(width),\n      Math.round(height)\n    )\n    // Draw the label background.\n    ctx.setFillStyle('#0062ff')\n    const textWidth = ctx.measureText(predictionText).width\n    ctx.fillRect(\n      Math.round(x - border / 2),\n      Math.round(y - (textHeight + yPadding) - offset),\n      Math.round(textWidth + xPadding),\n      Math.round(textHeight + yPadding)\n    )\n  })\n\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n\n    const predictionText = getLabelText(prediction)\n    // Draw the text last to ensure it's on top.\n    ctx.setFillStyle('#ffffff')\n    ctx.fillText(\n      predictionText,\n      Math.round(x - border / 2 + xPadding / 2),\n      Math.round(y - (textHeight + yPadding) - offset + yPadding / 2)\n    )\n  })\n}\n","import React, { useRef, useCallback } from 'react'\n\nimport useWebcam from './useWebcam'\nimport { getRetinaContext } from './retina-canvas'\nimport { renderPredictions } from './render-predictions'\n\nconst ObjectDetectionVideo = React.memo(\n  ({ model, onPrediction, fit, mirrored, render }) => {\n    const videoRef = useRef()\n    const canvasRef = useRef()\n\n    useWebcam(videoRef, () => {\n      detectFrame()\n    })\n\n    const detectFrame = useCallback(async () => {\n      const predictions = await model.detect(videoRef.current)\n      if (onPrediction) {\n        onPrediction(predictions)\n      }\n\n      const wantedWidth = videoRef.current.offsetWidth\n      const wantedHeight = videoRef.current.offsetHeight\n      const videoWidth = videoRef.current.videoWidth\n      const videoHeight = videoRef.current.videoHeight\n\n      const scaleX = wantedWidth / videoWidth\n      const scaleY = wantedHeight / videoHeight\n\n      let scale\n      if (fit === 'aspectFit') {\n        scale = Math.min(scaleX, scaleY)\n      } else {\n        scale = Math.max(scaleX, scaleY)\n      }\n\n      const xOffset = (wantedWidth - videoWidth * scale) / 2\n      const yOffset = (wantedHeight - videoHeight * scale) / 2\n\n      const ctx = getRetinaContext(canvasRef.current)\n\n      ctx.setWidth(wantedWidth)\n      ctx.setHeight(wantedHeight)\n      ctx.clearAll()\n\n      // Update predictions to match canvas.\n      const offsetPredictions = predictions.map((prediction) => {\n        let x = prediction.bbox[0] * scale + xOffset\n        const y = prediction.bbox[1] * scale + yOffset\n        const width = prediction.bbox[2] * scale\n        const height = prediction.bbox[3] * scale\n\n        if (mirrored) {\n          x = wantedWidth - x - width\n        }\n        return { ...prediction, bbox: [x, y, width, height] }\n      })\n\n      const renderFunction = render || renderPredictions\n\n      renderFunction(ctx, offsetPredictions)\n      requestAnimationFrame(() => {\n        detectFrame()\n      })\n    }, [fit, mirrored, model, onPrediction, render])\n\n    if (canvasRef.current) {\n      canvasRef.current.style.position = 'absolute'\n      canvasRef.current.style.left = '0'\n      canvasRef.current.style.top = '0'\n    }\n\n    if (videoRef.current) {\n      videoRef.current.style.width = '100%'\n      videoRef.current.style.height = '100%'\n      if (fit === 'aspectFit') {\n        videoRef.current.style.objectFit = 'contain'\n      } else {\n        videoRef.current.style.objectFit = 'cover'\n      }\n\n      if (mirrored) {\n        videoRef.current.style.transform = 'scaleX(-1)'\n      } else {\n        videoRef.current.style.transform = 'scaleX(1)'\n      }\n    }\n\n    return (\n      <div style={{ position: 'relative' }}>\n        <video autoPlay playsInline muted ref={videoRef} />\n        <canvas ref={canvasRef} />\n      </div>\n    )\n  }\n)\n\nexport default ObjectDetectionVideo\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport useModel from './useModel'\nimport ObjectDetectionVideo from './object-detection-video/ObjectDetectionVideo'\n\nimport './index.css'\n\nconst handlePrediction = (predictions) => {\n  console.timeEnd('detect')\n  console.time('detect')\n  console.log(predictions)\n}\n\nconst render = (ctx, predictions) => {\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    const width = prediction.bbox[2]\n    const height = prediction.bbox[3]\n\n    ctx.setStrokeStyle('#0062ff')\n    ctx.setLineWidth(4)\n    ctx.strokeRect(\n      Math.round(x),\n      Math.round(y),\n      Math.round(width),\n      Math.round(height)\n    )\n  })\n}\n\nconst App = () => {\n  const model = useModel(process.env.PUBLIC_URL + '/model_web')\n\n  return (\n    <div className=\"fillPage\">\n      <ObjectDetectionVideo\n        model={model}\n        // onPrediction={handlePrediction}\n        // render={render}\n        // aspectFill: The option to scale the video to fill the size of the view.\n        //             Some portion of the video may be clipped to fill the view's\n        //             bounds.\n        // aspectFit:  The option to scale the video to fit the size of the view\n        //             by maintaining the aspect ratio. Any remaining area of the\n        //             view's bounds is transparent.\n        fit=\"aspectFill\"\n        // mirrored:   mirror the video about its vertical axis.\n        mirrored\n      />\n    </div>\n  )\n}\n\nconst rootElement = document.getElementById('root')\nReactDOM.render(<App />, rootElement)\n"],"sourceRoot":""}